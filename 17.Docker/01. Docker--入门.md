[TOC]

# Docker

## 一、Docker概述

### 1. Docker为什么会出现？

**传统一款产品：**<font color='red'>开发--上线，两套环境，配置比较麻烦。</font>

**常见问题：**

1. 在我的电脑上可以运行。
2. 环境配置比较麻烦（集群配置比较麻烦）。

**解决方案：**

​	项目和环境一起打包部署上线。

**Docker简单介绍：**

​	Doker的<font color='red'>思想就来自于集装箱</font>。

​	传统：JRE -- 多个应用（端口冲突） -- 原来都是交叉的。

​	隔离：Docker核心思想！打包装箱！每个箱子是相互隔离。

**Docker与传统进行比较：**

​	传统：开发Jar，运维来做。

​	现在：开发打包部署上线，一套流程完成。

**采用Docker后的工作流程：**

​	Java -- Jar（环境）-- 打包项目带上环境（镜像）--  Docker仓库（商店）-- 下载我们发布的镜像 -- 直接运行即可。

### 2. Docker能做什么？

**1. 之前的虚拟机**

![image-20200817221537928](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200817221537928.png)

**虚拟机技术缺点：**

1. 资源占用十分多。
2. 冗余步骤多。
3. 启动很慢。

**2. Docker：**

![image-20200817221657214](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200817221657214.png)

**比较Docker和虚拟机的不同：**

* 传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后再这个系统上安装和运行软件。
* 容器内的应用直接运行在宿主机的内容，容器时没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了。
* 每个容器间是互相隔离的，每个容器内都有一个属于自己的文件系统，胡不影响。

### 3. DevOps（开发、运维）

**1. 应用更快速的交付和部署**

传统：一堆帮助文档，安装程序。

Docker：打包镜像发布测试，一键运行。

**2. 更便捷的升级和扩缩容**

使用了Docker之后我们部署就想搭积木一样。

项目打包为一个镜像，扩展 服务器A、服务器B

**3. 更简单的系统运维**

在容器化之后，我们的开发，测试环境都是高度一致的。

**4. 更高效的计算资源利用**
Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多个容器实例！服务器的性能可以被压榨到极限。

## 二、Docker安装

### 1. Docker的基本组成

![image-20200817225718407](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200817225718407.png)

<font color='red'>**镜像（image）：**</font>

docker镜像就好比是一个模板，可以通过这个模板来创建容器服务。

比如：Tomcat镜像 ===> Run ===>Tomcat01容器（提供服务），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。

**<font color='red'>容器（container）：</font>**

Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的。

启动，停止，删除等基本命令。

目前就可以把这个容器理解为就是一个简易的linux系统。

**<font color='red'>仓库（repository）：</font>**

仓库就是存放镜像的地方。

仓库分为共有仓库和私有仓库。

DockerHub（默认是国外的）

阿里云有国内镜像加速。

### 2. 安装Docker

#### 1）系统环境

```shell
# centos内核版本
[root@localhost ~]# uname -r
3.10.0-957.el7.x86_64
```



```shell
# 系统版本
[root@localhost ~]# cat /etc/os-release 
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"
```

#### 2）安装Docker

```shell
# 1. 卸载旧版本
yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
  
# 2.需要的安装包
yum install -y yum-utils

# 3.配置仓库镜像地址（国内阿里云）
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
# 4.更新yum
yum makecache fast
# 4.5 安装docker相关内容 docker-ce社区版|ee企业版本
yum install docker-ce docker-ce-cli containerd.io
# 5.启动docker
systemctl start docker
# 6.使用Docker检测是否安装成功
docker version
```

![image-20200817233848851](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200817233848851.png)

```shell
# 7.运行Helloworld
docker run hello-world
```

![image-20200817234504754](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200817234504754.png)

```shell
# 8.查看一下下载的这个Hello-world镜像
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        7 months ago        13.3kB
```

#### 3）卸载Docker

```shell
# 1.卸载依赖
yum remove docker-ce docker-ce-cli containerd.io
# 2.卸载资源
rm -rf /var/lib/docker
```

#### 4）配置阿里云镜像加速

<font color='red'>1.登录阿里云</font>

![image-20200817235651840](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200817235651840.png)

<font color='red'>2.找到镜像加速地址</font>

![image-20200817235430405](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200817235430405.png)

<font color='red'>3.配置实用</font>

```shell
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://1tbhwxlx.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```



## 三、Docker原理介绍

### 1. Docker run命令的原理流程图

<font color='red'>流程分析图</font>

![image-20200818125451094](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818125451094.png)

### 2. Docker底层原理

Docker是一个Client--Sercer结构的系统，Docker的守护线程运行在主机上。通过Socket从客户端访问！

DockerServer接收Docker--Client的指令，就会执行这个命令了。

![image-20200818130150636](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818130150636.png)

### 3. Docker为什么比VM虚拟机快？

![image-20200818133236334](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818133236334.png)

1. Docker有着比虚拟机更少的抽象层。
2. Docker利用的是宿主机的内核，vm需要时GuestOS。

![image-20200818140243439](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818140243439.png)

## 四、Docker常用命令

 ### 1. 帮助命令

```shell
docker version		# 显示docker的版本信息
docker info 		# 显示docker的系统信息，包括镜像和容器的数量
docker --help		# 帮助命令
```

帮助文档的地址：https://docs.docker.com/engine/reference/commandline/images/

### 2. 镜像命令

#### <font color='red'># docker images 查看所有本地主机上的镜像</font>

```shell
[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              bf756fb1ae65        7 months ago        13.3kB

# 解释
REPOSITORY  镜像的仓库源
TAG	        镜像的标签 
IMAGE ID    镜像的ID
CREATED		镜像的创建时间
SIZE		镜像的大小

# 可选项
-a, -all    显示所有镜像
-q          只显示ID
```

#### <font color='red'># docker search 查询镜像</font>

```shell
[root@localhost ~]# docker search mysql
NAME        DESCRIPTION                                      STARS               
mysql       MySQL is a widely used, open-source relation…    9854                [OK]                
mariadb     MariaDB is a community-developed fork of MyS…    3599                [OK] 

# 可选项
 --filter=STARS=3000  #搜索出来的镜像为STARS大于3000的
```

#### <font color='red'># docker pull下载镜像</font>

```shell
# 下载镜像 docker pull 镜像名[:tag]版本号
[root@localhost ~]# docker pull mysql # 默认使用最新版
Using default tag: latest
latest: Pulling from library/mysql
bf5952930446: Pull complete  # 分层下载，docker image的核心 联合文件系统
8254623a9871: Pull complete 
938e3e06dac4: Pull complete 
ea28ebf28884: Pull complete 
f3cef38785c2: Pull complete 
894f9792565a: Pull complete 
1d8a57523420: Pull complete 
6c676912929f: Pull complete 
ff39fdb566b4: Pull complete 
fff872988aba: Pull complete 
4d34e365ae68: Pull complete 
7886ee20621e: Pull complete 
Digest: sha256:c358e72e100ab493a0304bda35e6f239db2ec8c9bb836d8a427ac34307d074ed #签名
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest # 真实地址

# 两者关系等价
docker pull mysql
docker pull docker.io/library/mysql:latest

# 指定版本下载
[root@localhost ~]# docker pull mysql:5.7
5.7: Pulling from library/mysql
bf5952930446: Already exists 
8254623a9871: Already exists 
938e3e06dac4: Already exists 
ea28ebf28884: Already exists 
f3cef38785c2: Already exists 
894f9792565a: Already exists 
1d8a57523420: Already exists 
5f09bf1d31c1: Pull complete 
1b6ff254abe7: Pull complete 
74310a0bf42d: Pull complete 
d398726627fd: Pull complete 
Digest: sha256:da58f943b94721d46e87d5de208dc07302a8b13e638cd1d24285d222376d6d84
Status: Downloaded newer image for mysql:5.7
docker.io/library/mysql:5.7
```

#### <font color='red'># docker rmI删除镜像</font>

```shell
# 通过镜像id删除
docker rmi -f 0d64f46acfd1
# 删除多个镜像
docker rmi -f 0d64f46acfd1 718a6da099d8
# 递归删除所有镜像
docker rmi -f $(docker images -aq)
```

### 3. 容器命令

<font color='red'>有了镜像才可以创建容器。需要下载一个Centos镜像来测试学习</font>

#### <font color='red'># docker pull 拉取镜像 </font>

```shell
docker pull centos
```

#### <font color='red'>#docker run 新建容器并启动</font>

```shell
docker run [可选参数] image

# 参数说明
--name="Name"   # 容器名字 mysql01 mysql02
-d 			    # 后台运行
-it				# 使用交互方式运行，进入容器查看内容
-p				# 制定容器的端口
	-ip:主机短裤：容器端口
	-p 主机端口：容器端口（常用）
	-p 容器端口
	容器端口
-P				# 随机制定端口

# 测试：启动并进入容器
[root@localhost ~]# docker run -it centos /bin/bash
[root@ac4ea0e663e6 /]# ls #查看容器内部的centos,基础版本，很多命令都是不完善的！
bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var
dev  home  lib64  media       opt  root  sbin  sys  usr

# 从容其中退回到主机
[root@ac4ea0e663e6 /]# exit
exit
```

#### <font color='red'># docker ps 列出所有的运行过的容器</font>

```shell
# docker ps命令
-a   #列出当前正在运行的容器+带出历史运行过的容器
-n=? # 显示最近创建的容器
-q   # 只显示容器的编号
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@localhost ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                          PORTS               NAMES
ac4ea0e663e6        centos              "/bin/bash"         4 minutes ago       Exited (0) About a minute ago                       magical_shtern
c4b7cac1f9ef        bf756fb1ae65        "/hello"            3 hours ago         Exited (0) 3 hours ago                              blissful_mcclintock
```

#### <font color='red'># exit 退出容器</font>

```shell
exit # 直接容器停止并退出
Ctrl + P + Q # 容器不停止运行
```

#### <font color='red'># rm 删除容器</font>

```shell
docker rm 容器id  		        # 删除指定的容器（不能删除运行中的容器，可以-f强制删除）
docker rm -f $(docker ps -aq)    # 删除所有的容器（强制删除）
docker ps -a -q|xargs docker rm  # 删除所有容器
```

#### <font color='red'># 启动和停止容器的操作</font>

```shell
docker start 容器id    # 启动当前容器
docker restart 容器id  # 重启当前容器
docker stop 容器id     # 停止当前容器
docker kill 容器id     # 强制停止当前容器
```

### 4. 常用的其他命令

#### <font color='red'># docker run -d  后台启动</font>

```shell
# 命令 docker run -d centos
[root@localhost ~]# docker run -d centos
267d96c972a061ebffe5dca3329b909617b6ed5bcc517714cc9be9f562e4d2a1

# 问题docker ps，发现centos停止了

# 常见的坑，docker容器使用后台运行，就必须要有一个前台进程，
# nginx, 容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了
```

#### <font color='red'># docker logs 查看日志</font>

```shell
docker logs 
Options:
      --details        显示提供给日志的额外细节
  -f, --follow         跟踪日志输出
      --since string   显示自时间戳
      --tail string    日志末尾显示的行数(默认为“all”)
  -t, --timestamps     显示时间戳
      --until string   在时间戳(比如2013-01-02T13:23:37)或亲戚(比如42m, 42分钟)之前显示日志

# 自己写一段shell脚本测试一下
"while true; do echo zhangsan;sleep 1;done"
[root@localhost ~]# docker run -d centos /bin/sh -c "while true; do echo zhangsan; sleep 1; done"
e7dc83ba767a38010397476722370828cedbbd171bb62fba9414bd7f61312b68
[root@localhost ~]# docker logs -tf --tail 10  e7dc83ba767a 
2020-08-18T09:15:38.221538636Z zhangsan
2020-08-18T09:15:39.224374185Z zhangsan
2020-08-18T09:15:40.230658560Z zhangsan
2020-08-18T09:15:41.232771054Z zhangsan
2020-08-18T09:15:42.237076486Z zhangsan
2020-08-18T09:15:43.250861287Z zhangsan
2020-08-18T09:15:44.253696064Z zhangsan
2020-08-18T09:15:45.258438163Z zhangsan
2020-08-18T09:15:46.262790453Z zhangsan
2020-08-18T09:15:47.268906802Z zhangsan
```

#### <font color='red'># docker top 查看容器中进程信息</font>

```shell
# 命令 Docker top 容器id
[root@localhost ~]# docker top e7dc83ba767a
UID   PID     PPID    C   STIME   TTY    TIME     CMD
root  14079   14060   0   17:13    ?     00:00:00  /bin/sh -c while true; do echo zhangsan; sleep 1; done
root  14405   14079   0   17:17    ?     00:00:00  
```

#### <font color='red'># docker inspect 查看镜像源数据</font>

```shell
# docker inspect e7dc83ba767a
[root@localhost ~]# docker inspect e7dc83ba767a
[
    {
        "Id": "e7dc83ba767a38010397476722370828cedbbd171bb62fba9414bd7f61312b68",
        "Created": "2020-08-18T09:13:48.04159538Z",
        "Path": "/bin/sh",
        "Args": [
            "-c",
            "while true; do echo zhangsan; sleep 1; done"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 14079,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2020-08-18T09:13:48.729041829Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:0d120b6ccaa8c5e149176798b3501d4dd1885f961922497cd0abef155c869566",
        "ResolvConfPath": "/var/lib/docker/containers/e7dc83ba767a38010397476722370828cedbbd171bb62fba9414bd7f61312b68/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/e7dc83ba767a38010397476722370828cedbbd171bb62fba9414bd7f61312b68/hostname",
        "HostsPath": "/var/lib/docker/containers/e7dc83ba767a38010397476722370828cedbbd171bb62fba9414bd7f61312b68/hosts",
        "LogPath": "/var/lib/docker/containers/e7dc83ba767a38010397476722370828cedbbd171bb62fba9414bd7f61312b68/e7dc83ba767a38010397476722370828cedbbd171bb62fba9414bd7f61312b68-json.log",
        "Name": "/gallant_torvalds",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "Capabilities": null,
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/b902ede4a5cb10aaf3bed3fbd3f416da8c45ad63d831ed09e6509056178cadff-init/diff:/var/lib/docker/overlay2/e3a30361f22fb80f1ffe4b171c48dd02db83cb92fbbeca294bcc24356dca2a1a/diff",
                "MergedDir": "/var/lib/docker/overlay2/b902ede4a5cb10aaf3bed3fbd3f416da8c45ad63d831ed09e6509056178cadff/merged",
                "UpperDir": "/var/lib/docker/overlay2/b902ede4a5cb10aaf3bed3fbd3f416da8c45ad63d831ed09e6509056178cadff/diff",
                "WorkDir": "/var/lib/docker/overlay2/b902ede4a5cb10aaf3bed3fbd3f416da8c45ad63d831ed09e6509056178cadff/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "e7dc83ba767a",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "while true; do echo zhangsan; sleep 1; done"
            ],
            "Image": "centos",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.label-schema.build-date": "20200809",
                "org.label-schema.license": "GPLv2",
                "org.label-schema.name": "CentOS Base Image",
                "org.label-schema.schema-version": "1.0",
                "org.label-schema.vendor": "CentOS"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "b33b67963a1605101db0737e50420d37f5d197a2c6cec1df08ae8934923b5121",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/b33b67963a16",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "b3c4e62f6e82ae96a13a973a7334c48fd331a5aaf65233ede27c2375165d9fb2",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "2b75ccf049bc12606fbe2fded9e5955ae7e5c4ee00dc142b472ac62c4edc16f1",
                    "EndpointID": "b3c4e62f6e82ae96a13a973a7334c48fd331a5aaf65233ede27c2375165d9fb2",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]

```

#### <font color='red'>#docker exec[attach] 进入当前正在运行的容器</font>

```shell
# 我们的容器通常是使用后台进行的，需要进入容器，修改一些配置

# 命令docker ps进入容器
[root@localhost ~]# docker exec -it e7dc83ba767a /bin/bash
[root@e7dc83ba767a /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@e7dc83ba767a /]# 

# 方式二：docker attach
docker attach 容器id
[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
e7dc83ba767a        centos              "/bin/sh -c 'while t…"   12 minutes ago      Up 12 minutes                           gallant_torvalds
[root@localhost ~]# docker attach e7dc83ba767a

# 两者区别
# Docker exec 进入容器后进入一个新的终端，可以在里面操作（常用）
# Docker attach 进入容器正在执行的终端，不会启动新进程。
```

#### <font color='red'># docker cp  从容器内拷贝文件</font>

```shell
# 命令# docker cp e7dc83ba767a:/home/test.java /home
[root@e7dc83ba767a /]# cd /home 
[root@e7dc83ba767a home]# touch test.java
[root@e7dc83ba767a home]# exit
exit
[root@localhost ~]# docker cp e7dc83ba767a:/home/test.java /home
[root@localhost ~]# cd /home
[root@localhost home]# ls
miaoKa  test.java  yuqing  zhangshuai

```

拷贝是一个手动过程，未来我们使用-v卷的技术可以实现自动同步。

### 5. 命令总结

![image-20200818175352252](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818175352252.png)

Docker命令A-Z

```shell

```

### 6. Docker命令练习实例

#### # <font color='red'>1. 创建一个Nginx容器并运行相关操作</font>

```shell
# 1. 寻找Nginx镜像，也可以跳过这一步直接pull/run
docker search nginx
# 2. 拉取ngnix镜像
docker pull nginx
# 3. 运行ngnix容器
docker run -d -p 3344:80 --name ngnix01 ngnix
# 4. 检测是否成功运行
curl localhost:3344
# 5.配置文件
docker exec -it ngnix01 /bin/bash
```

#### # <font color='red'>2. 创建一个Tomcat容器并运行相关操作</font>

```shell
# 1. Tomcat
docker search tomcat
# 2. 拉取Tomcat9.0
docker pull tomcat:9.0
# 3. 启动Tomcate
docker run -d -p 3355:8080 --name tomcat9-01 tomcat:9.0
# 启动之后是阉割简洁版的，要想正常运行需要稍作配置
cp -r webapp.dist/* webapps
```

#### # <font color='red'>3. 部署ES+Kibana</font>

```shell
# 1.运行ES容器
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2

# 2.运行后发现特别的卡(ES是十分消耗内存的) 通过docker stats查询状态
docker stats

# 3.修改配置文件再次运行
docker run -d --name elasticsearch2 -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2

# 4.测试运行成功
curl localhost:9200
{
  "name" : "ee57d92e443e",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "z6RfJnBlSh62G_-RoyqMyA",
  "version" : {
    "number" : "7.6.2",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
    "build_date" : "2020-03-26T06:34:37.794943Z",
    "build_snapshot" : false,
    "lucene_version" : "8.4.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}

```

预留问题：Kibana需要在内部链接Es（容器内部互相隔离，不能够直接使用localhost:9200来链接），可通过Docker内部网络连接。

![image-20200818222206871](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818222206871.png)



## 五、可视化工具

### 1.Portainer

Docker图像化界面管理工具，提供一个后台面板管理系统。

```shell
docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
```

测试：localhost:8088

进来后先设置密码。

![image-20200818223416773](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818223416773.png)

选择本地

![image-20200818223507878](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818223507878.png)

![image-20200818223645231](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818223645231.png)

可视化面板我们平时不会用，用来测试玩玩。

### 2.Rancher



## 六、Docker镜像

### 1. 镜像是什么

镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的的软件，他包含运行某个软件所需的所有内容，包括代码、运行时环境、配置变量等。

<font color='red'>如何得到镜像：</font>

* 从远程仓库下载。
* 朋友拷贝给你。
* 自己制作镜像。

### 2. Docker镜像加载原理

#### # <font color='red'>UnionFS 联合文件系统</font>

UnionFS联合文件系统：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同事可以将不同目录挂在到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。镜像可以通过分层来进行集成，基于基础镜像，可以制作各种具体的应用镜像。

特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。

#### # <font color='red'>Doker镜像加载原理</font>

![image-20200818231506097](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818231506097.png)

![image-20200818231428337](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818231428337.png)

![image-20200818231243586](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818231243586.png)

![image-20200818231612983](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818231612983.png)

<font color='red'>不同的Linux版本，Bootfs基本一致，Rootfs会有差别，因此不同的发行版可以用共同的Bootfs</font>

### 3. 分层原理

<font color='red'>每操作一步，就会加一层。</font>

![image-20200818232152987](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818232152987.png)

<font color='red'>文件5被替换掉了。</font>

**特点：**

Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部。

这一层就是我们通常说的容器层，容器层之下的都叫镜像层。

![image-20200818232457859](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200818232457859.png)

### 4. Docker commit 提交镜像

**<font color='red'>命令：</font>**

```shell
docker commit -m="提交的描述" -a="作者" 容器id 目标镜像名:[TAG版本号]
```

<font color='orange'>实战测试：</font>

```shell
# 前言：Tomcat9.0中的webapp目录被删减了，需要去webapp.dist中copy。
# 我们就去copy然后再上传镜像

# 1. 启动Tomcat9.0镜像
[root@localhost ~]# docker run -d -p=3344:8080 tomcat:9.0

# 2. 进入容器内部，copy webapp.dist文件
root@93ec08a5de4b:/usr/local/tomcat/webapps# cp -r ../webapps.dist/* ../webapps/ 

# 3. 提交容器镜像
[root@localhost ~]# docker commit -m="domcat9.0-good" -a="zhangshuai" fc96b96958d9 tomcatg:1.0

# 4. 查看镜像
[root@localhost ~]# docker images
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
tomcatg               1.0                 03f909611ed9        8 seconds ago       79.1MB
```



## 七、容器数据卷

### 1. 什么是容器数据卷

<font color='red'>前言：Docker的目的是将应用和环境一起打包。</font>

<font color='red'>需求：如果数据在容器中，那我们删除容器，数据也会丢失掉。所以我们需要数据持久化。</font>

容器之间可以有一个数据共享技术！Docker容器中产生的数据，同步到目录！

这就是卷技术！也就是目录的挂在，将我们容器内的目录，挂载到linux或虚拟机上面。

**原理图：**

![image-20200819143544678](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200819143544678.png)

**作用：**

1. 容器的持久化和同步操作。
2. 荣期间也是可以数据共享的。

### 2. 使用数据卷

#### # <font color='red'>方式一：通过docker run -v</font>

```shell
docker run -it -v 主机目录：容器目录
```

**测试1：**

```shell
# 1.测试
docker run -it -v /home/test:/home centos /bin/bash

# 2.查看容器详细信息
docker inspect 容器id
```

![image-20200819144142029](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200819144142029.png)

```SHELL
# 3.测试有没有真正实现映射

# 4.容器停止后就该主机文件也会同步到容器
```

##### ## <font color='red'>通过方式一实战：部署Mysql</font>

Mysql的数据持久化问题：Mysql中的Data数据文件。

```shell
# 1.获取镜像
[root@localhost ~]# docker pull mysql:5.7

# 2.运行容器 启动mysql是需要配置密码的
# 官方：docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag
docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7

# 在本地创建数据库，查看映射路径是否ok，如果同步则ok。
```

<font color='red'>假设我们把容器删除，本地的数据卷依旧存在。这样就是实现了容器持久化的功能。</font>

#### # 方式二：DockerFile

DockerFile就是用来构建docker镜像的构建文件。命令脚本。

<font color='red'>**作用：通过脚本生成镜像。**</font>**<font color='orange'>其中每个命令就是镜像中的一层。</font>**

##### ## 通过DockerFile创建镜像并挂载数据卷

```shell
# 1.创建一个测试目录 
[root@localhost home]# mkdir docker-test-volume

# 2.创建dockerfile文件
[root@localhost docker-test-volume]# vi dockerfile01

# 3.编辑里面的内容
[root@localhost docker-test-volume]# cat dockerfile01 
FROM centos
VOLUME ["volum01","volum02"]
CMD echo "-----end-----"
CMD /bin/bash
```

```shell
# 4.运行脚本
[root@localhost docker-test-volume]# docker build -f ./dockerfile01 -t zhangsan/centos:1.0 . 
Sending build context to Docker daemon  2.048kB
Step 1/4 : FROM centos
 ---> 0d120b6ccaa8
Step 2/4 : VOLUME ["volum01","volum02"]
 ---> Running in 69b4e9217f9f
Removing intermediate container 69b4e9217f9f
 ---> 4eb8bd028280
Step 3/4 : CMD echo "-----end-----"
 ---> Running in 4aa4a74bc7b2
Removing intermediate container 4aa4a74bc7b2
 ---> b24ba278a689
Step 4/4 : CMD /bin/bash
 ---> Running in 8ae765ba546f
Removing intermediate container 8ae765ba546f
 ---> bb2efb89e782
Successfully built bb2efb89e782
Successfully tagged zhangsan/centos:1.0
```

由上可见，他是一层一层Build的。

```shell
# 5.查看创建的镜像
[root@localhost /]# docker images
REPOSITORY            TAG                 IMAGE ID            CREATED              SIZE
zhangsan/centos       1.0                 bb2efb89e782        About a minute ago   215MB
# 运行创建后的镜像
[root@localhost /]# docker run -it zhangsan/centos:1.0 /bin/bash
```

![image-20200819182747859](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200819182747859.png)

<font color='red'>**分析：**</font>

这是一个匿名挂载。我们来查询他的位置。

```shell
[root@localhost /]# docker inspect zhangsan/centos:1.0
```

<font color='red'>我们发现卷的位置：</font>

![image-20200819183304007](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200819183304007.png)

**<font color='red'>总结：</font>**

这种方式我们未来使用的十分多，因为我么通常会构建自己的镜像。

假设构建镜像时候没有挂载卷，要手动挂载（-v）

### 3. 具名和匿名挂载

#### # <font color='red'>匿名挂载</font>

```shell
-v 容器内路径
# 匿名挂载
docker run -d -P --name ngnix01 -v /ect/nginx nginx
```

这种就是匿名挂载。

通过`docker volume ls`可以查看所有卷。

```shell
[root@localhost data]# docker volume ls
DRIVER              VOLUME NAME
local               881fa5483bc125171501fb3d917e9da4d5cfb1e0e329dfdca07b788e5e9dc700
local               81450aa4578fe83035dd161763ee5f36749e688e40aac9981f635201421ec4e5
```

像这种就是匿名挂载。

#### # <font color='red'>具名挂载</font>

```shell
-v volumeName:容器内路径
# 具名挂载
docker run -d -P --name ngnix02 -v juming-ngnix:/etc/nginx nginx
```

同样使用`docker volume ls`可以查看所有卷。

```shell
[root@localhost data]# docker volume ls
DRIVER              VOLUME NAME
local               juming-nginx
```

这种就叫做具名。

#### # 在没有指定目录的情况下卷都存在哪里

通过 docker volume inspect 卷名可查看卷的详情信息。

```shell
[root@localhost data]# docker volume inspect juming-nginx
[
    {
        "CreatedAt": "2020-08-19T16:24:01+08:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/juming-nginx/_data",
        "Name": "juming-nginx",
        "Options": null,
        "Scope": "local"
    }
]
```

<font color='red'>发现：没有指定路径的卷都会存在于</font>`/var/lib/docker/volumes/卷name/_data`<font color='red'>路径下。</font>

#### # <font color='red'>拓展：ro/rw</font>

ro: readonly只读 这个路径只能通过宿主机来进行操作，容器内部无法操作
rw：readwrite可读可写

使用效果：

```shell
docker run -d -P --name ngnix02 -v juming-ngnix:/etc/nginx:ro nginx
docker run -d -P --name ngnix02 -v juming-ngnix:/etc/nginx:rw nginx
```

 **<font color='red'>一旦设置了容器权限，容器对我们挂载出来的内容就有限制了</font>**

### 4. 数据卷容器

![image-20200820000540024](F:\工作\记录\17.Docker\01. Docker--入门.assets\image-20200820000540024.png)



## DockerFile

## Docker网络原理

## IDEA整合Docker

## Docker Compose

## Docker Swarm

## Docker Swarm

## CI\CD Jenkins



