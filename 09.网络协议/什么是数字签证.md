[TOC]

# 什么是数字签名

## 1. 场景模拟

1.鲍勃有两把钥匙，一把是**公钥**，另一把是**私钥**。

2.鲍勃把公钥送给他的朋友们----帕蒂、道格、苏珊----每人一把。

3.苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。

4.鲍勃收信后，用私钥解密，就看到了信件内容。**这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。**

> 客户端给服务器发送消息，可以通过服务器的公钥进行加密。然后服务器使用私钥进行解密

5.鲍勃给苏珊回信，决定采用"数字签名"。他写完后先用Hash函数，生成信件的摘要（digest）。

6.然后，鲍勃使用私钥，对这个摘要加密，生成"数字签名"（signature）。

7.鲍勃将这个签名，附在信件下面，一起发给苏珊。

8.苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。

9.苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。

> 服务器给客户端发送消息。通过通过Hash函数生成内容摘要，然后通过私钥对摘要进行加密，这就形成了数字签名。
>
> 服务器再将签名和信件一起发送给客户端。客户端通过公钥解开摘要，再对信件通过Hash生成的摘要进行对比。如果一样则证明这个新建就是服务器发送过来的。

10.复杂的情况出现了。

道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。

此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。

因此，道格就可以冒充鲍勃，用自己的私钥做成"数字签名"，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。

> 如果有人偷偷把你的公钥掉包了，客户端不知道自己拿到的是一个假的公钥，这样就可能造成客户端接收到一个假的服务器发过来的假信息。

11.后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。

她想到了一个办法，要求鲍勃去找"证书中心"（certificate authority，简称CA）为公钥做认证。

证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成"数字证书"（Digital Certificate）。

12.鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。

13.苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明"数字签名"是否真的是鲍勃签的。

> 证书中心CA，CA通过自己的私钥对委托服务器的公钥进行加密，生成了数字证书。
>
> 服务器再次给客户端发送消息事，在发送签名的同时再附加上数字证书。
>
> 客户端使用CA的公钥解开数字证书，拿到里面的公钥，就可以证明数字签名是是不是来自真的服务器。

## 2. 数字证书生成的过程

　1、使用数字证书申请者的身份信息生成数字签名

![image-20200917222659784](F:\工作\记录\09.网络协议\什么是数字签证.assets\image-20200917222659784.png)

2、将证书申请者的身份信息和数字签名一起组成数字证书

![image-20200917222731689](F:\工作\记录\09.网络协议\什么是数字签证.assets\image-20200917222731689.png)

3.数字证书原理

有了数字证书以后，A和想跟B通信，就可以通过B的数字证书来获取B的公钥，以达到验证自己手中的公钥到底是不是B的目的。过程是这样的：

a. B给A回信的时候，在信息后面附上了自己的数字证书。

b. A收到B的回信以后，会取出附带的数字证书，并读取证书中的发布机构（Issuer），然后从操作系统的受信任证书机构列表中查找该证书办发机构的公钥，如果找不到，说明这个证书颁发机构是个不受信任的，B发过来的信息当然也是不安全的。

c. 使用上一步取到的证书颁发机构的公钥，解出数字证书，得到可能是B的用户信息和数字签名。

d. A通过证书中指定的加密算法对可能是B的用户信息进行hash加密。

f. 加密后的结果和证书中解出的数字签名进行对比，如果相同，就说明这份用户信息确实是B的，也就是说用户信息中包含的公钥确实是B的。