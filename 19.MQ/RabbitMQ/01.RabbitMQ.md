# RabbitMQ

## 一、什么是MQ

**消息队列(Message Queue，简称MQ)**，先入先出，存放内容为message。

消息总线（Message Queue），后文称MQ，是一种跨进程的通信机制，用于上下游传递消息。

**<font color='red'>为什么会产生消息队列？</font>**

[《Java 帝国之消息队列》](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513507&idx=1&sn=d6db79c1ae03ba9260fb0fb77727bb54&chksm=80d67a60b7a1f376e7ad1e2c3276e8b565f045b1c7e21ef90926f69d99f969557737eb5d8128&mpshare=1&scene=1&srcid=1019awkBx8kaLyFohcuW4Ee7)

## 二、应用场景

### 1. 什么场景适用MQ

**<font color='red'>1）【典型场景一：数据驱动的任务依赖】</font>**

互联网公司经常在凌晨进行一些数据统计任务，这些任务之间有一定的依赖关系，比如：

```shell
1. task3需要使用task2的输出作为输入
2. task2需要使用task1的输出作为输入
```

这样的话，tast1, task2, task3之间就有任务依赖关系，必须task1先执行，再task2执行，载task3执行。

最初的设计方式：使用cron人工排执行时间表

```shell
1）task1，0:00执行，经验执行时间为50分钟
2）task2，1:00执行（为task1预留10分钟buffer），经验执行时间也是50分钟
3）task3，2:00执行（为task2预留10分钟buffer）

# 缺点
# 1）帖子发布流程的执行时间增加了
# 2）下游服务当机，可能导致帖子发布服务受影响，上下游逻辑+物理依赖严重
# 3）每当增加一个需要知道“帖子发布成功”信息的下游，修改代码的是帖子发布服务，这一点是最恶心的，属于架构设计中典型的依赖倒转，**谁用过谁痛谁知道**（采用此法的请评论留言）
```

优化后的方式：采用MQ进行解耦

```shell
1）task1准时开始，结束后发一个“task1 done”的消息
2）task2订阅“task1 done”的消息，收到消息后第一时间启动执行，结束后发一个“task2 done”的消息
3）task3同理

# 优点：
# 1）上游执行时间短
# 2）上下游逻辑+物理解耦，除了与MQ有物理连接，模块之间都不相互依赖
# 3）新增一个下游消息关注方，上游不需要修改任何代码
```

**<font color='red'>2）【典型场景二：上游不关心执行结果】</font>**

比如发送邮件。

**<font color='red'>3）【典型场景三：上游关注执行结果，但执行时间很长】</font>**

比如支付。

**流程：**1）调用方直接跨公网调用微信接口。
			2）微信返回调用成功，此时并不代表返回成功。
			3）微信执行完成后，回调统一网关。
			4）网关将返回结果通知MQ。
			5）请求方收到结果通知。

### 2. 什么场景下不适用MQ

既然MQ是互联网分层架构中的解耦利器，那所有通讯都使用MQ岂不是很好？

**这是一个严重的误区**，调用与被调用的关系，是无法被MQ取代的。

MQ的**不足**是：
1）系统更复杂，多了一个MQ组件
2）消息传递路径更长，延时会增加
3）消息可靠性和重复性互为矛盾，消息不丢不重难以同时保证
4）上游无法知道下游的执行结果，这一点是很致命的

```shell
# 举例 :
# -> 用户登录场景，登录页面调用passport服务，passport服务的执行结果直接影响登录结果，
# -> 此处的“登录页面”与“passport服务”就必须使用调用关系，而不能使用MQ通信。
```

无论如何，记住这个**结论**：**调用方实时依赖执行结果的业务场景，请使用调用，而不是MQ**。

## 三、 RabbitMQg

